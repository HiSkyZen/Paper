From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Sun, 12 Nov 2023 16:56:03 -0800
Subject: [PATCH] work on bytecode modifier


diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/ClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/ClassloaderBytecodeModifier.java
index 93b5196a960f3efbe0d28f5527ea2752426213ce..315b84d8e323fdd235f23d90b374154458938321 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/ClassloaderBytecodeModifier.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/ClassloaderBytecodeModifier.java
@@ -11,7 +11,7 @@ public interface ClassloaderBytecodeModifier {
         return Provider.INSTANCE;
     }
 
-    byte[] modify(PluginMeta config, byte[] bytecode);
+    byte[] modify(ClassLoader classLoader, PluginMeta config, byte[] bytecode);
 
     class Provider {
 
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java
deleted file mode 100644
index f9a2c55a354c877749db3f92956de802ae575788..0000000000000000000000000000000000000000
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package io.papermc.paper.plugin.entrypoint.classloader;
-
-import io.papermc.paper.plugin.configuration.PluginMeta;
-
-// Stub, implement in future.
-public class PaperClassloaderBytecodeModifier implements ClassloaderBytecodeModifier {
-
-    @Override
-    public byte[] modify(PluginMeta configuration, byte[] bytecode) {
-        return bytecode;
-    }
-}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperSimplePluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperSimplePluginClassLoader.java
index 6688f2af4a32c2f79785f162e2eac0330d439ac1..ea5c1d83dee65e0881fc6fc1dc3ca27abc993c38 100644
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperSimplePluginClassLoader.java
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperSimplePluginClassLoader.java
@@ -73,7 +73,7 @@ public class PaperSimplePluginClassLoader extends URLClassLoader {
             throw new ClassNotFoundException(name, ex);
         }
 
-        classBytes = ClassloaderBytecodeModifier.bytecodeModifier().modify(this.configuration, classBytes);
+        classBytes = ClassloaderBytecodeModifier.bytecodeModifier().modify(this, this.configuration, classBytes);
 
         int dot = name.lastIndexOf('.');
         if (dot != -1) {
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..d5e3e2ec145de0af3de12460aa5acef6ba4b5f60
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public interface ClassContext {
+
+    String className();
+
+    @Nullable String superClassName();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..cbd0e83fb555dda83deb4c6588fc6804316a0935
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java
@@ -0,0 +1,18 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import java.lang.constant.ClassDesc;
+
+public final class DescriptorUtils {
+
+    public static ClassDesc fromOwner(final String owner) {
+        return ClassDesc.ofDescriptor("L" + owner + ";");
+    }
+
+    public static String toOwner(final ClassDesc desc) {
+        final String descriptor = desc.descriptorString();
+        return descriptor.substring(1, descriptor.length() - 1);
+    }
+
+    private DescriptorUtils() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..e82755fa7ffc2e0bba200b9f42765528561b2623
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import com.google.common.collect.Iterators;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.versions.API_1_20_2;
+import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import net.minecraft.Util;
+import org.objectweb.asm.Opcodes;
+
+public class PaperClassloaderBytecodeModifier implements ClassloaderBytecodeModifier {
+
+    static final Map<String, ModifierFactory> MODIFIERS = Util.make(new LinkedHashMap<>(), map -> {
+        map.put("1.20.2", API_1_20_2::new);
+    });
+
+    @Override
+    public byte[] modify(final ClassLoader classLoader, final PluginMeta configuration, byte[] bytecode) {
+        int start = -1;
+        if (configuration.getAPIVersion() != null) {
+            int i = 0;
+            for (final Map.Entry<String, ModifierFactory> entry : MODIFIERS.entrySet()) {
+                final int pluginIdx = PluginConfigConstraints.VALID_PAPER_VERSIONS.indexOf(configuration.getAPIVersion());
+                final int modifierIdx = PluginConfigConstraints.VALID_PAPER_VERSIONS.indexOf(entry.getKey());
+                if (pluginIdx <= modifierIdx) {
+                    start = i;
+                    break;
+                }
+                i++;
+            }
+        } else {
+            start = 0;
+        }
+        if (start == -1) {
+            return bytecode; // no modification needed. The plugin version is newer than all versioned modifiers
+        }
+
+        final Iterator<Map.Entry<String, ModifierFactory>> iter = MODIFIERS.entrySet().iterator();
+        Iterators.advance(iter, start);
+        while (iter.hasNext()) {
+            final VersionedClassloaderBytecodeModifier modifier = iter.next().getValue().create(Opcodes.ASM9);
+            bytecode = modifier.modify(classLoader, configuration, bytecode);
+        }
+        return bytecode;
+    }
+
+    private interface ModifierFactory {
+
+        VersionedClassloaderBytecodeModifier create(int api);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..34b7b69527264c672338623f13bc2c6858d1debb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.ClassVisitor;
+
+public abstract class VersionedClassloaderBytecodeModifier extends ClassVisitor implements ClassloaderBytecodeModifier, ClassContext {
+
+    private @MonotonicNonNull String className;
+    private @Nullable String superClassName;
+
+    protected VersionedClassloaderBytecodeModifier(final int api) {
+        super(api);
+    }
+
+    @Override
+    public void visit(final int version, final int access, final String name, final @Nullable String signature, final @Nullable String superName, final String @Nullable [] interfaces) {
+        super.visit(version, access, name, signature, superName, interfaces);
+        this.className = name;
+        this.superClassName = superName;
+    }
+
+    @Override
+    public String className() {
+        return this.className;
+    }
+
+    @Override
+    public @Nullable String superClassName() {
+        return this.superClassName;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..f63c305dff1e754cdaea4f0f8055ed850eab6d5a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java
new file mode 100644
index 0000000000000000000000000000000000000000..f1452d345179a070ed237c6e86c24a1faec53a54
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
+
+public record ChangeParameter(Predicate<String> owner, NameAndDescPredicate nameAndDesc, ClassDesc oldParam, ClassDesc newParam) implements MethodRewriteRule {
+
+    @Override
+    public Rewrite rewrite(final ClassContext context, final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+        return new Rewrite(opcode, owner, name, this.replaceParameter(descriptor), isInterface);
+    }
+
+    private String replaceParameter(final String initialDescriptor) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(initialDescriptor);
+        ClassDesc[] parameterArray = desc.parameterArray();
+        for (int i = 0; i < parameterArray.length; i++) {
+            final ClassDesc classDesc = parameterArray[i];
+            if (classDesc.equals(ChangeParameter.this.oldParam())) {
+                desc = desc.changeParameterType(i, ChangeParameter.this.newParam());
+            }
+        }
+        return desc.descriptorString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3f904bbc1ebf36c6f74d767900d220079bafef3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java
@@ -0,0 +1,27 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.util.function.Predicate;
+
+/**
+ * Using this type requires that the actual type of the returned value not be changed so a cast
+ * will still succeed. This is significantly simpler than trying to handle actually changing
+ * the type.
+ */
+public record ChangeReturnType(Predicate<String> owner, NameAndDescPredicate nameAndDesc, ClassDesc oldReturn, ClassDesc newReturn) implements MethodRewriteRule {
+
+    @Override
+    public Rewrite rewrite(final ClassContext context, final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+        return new Rewrite(opcode, owner, name, this.replaceReturnType(descriptor), isInterface);
+    }
+
+    private String replaceReturnType(final String initialDescriptor) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(initialDescriptor);
+        if (desc.returnType().equals(this.oldReturn())) {
+            desc = desc.changeReturnType(this.newReturn());
+        }
+        return desc.descriptorString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..65709f020035a0e89f2870005f02a3cd9fdbad2c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
+
+public interface MethodRewriteRule extends RewriteRule {
+
+    String LAMBDA_METAFACTORY_OWNER = "java/lang/invoke/LambdaMetafactory";
+
+    Predicate<String> owner();
+
+    NameAndDescPredicate nameAndDesc();
+
+    @Override
+    default MethodVisitor createVisitor(final int api, final MethodVisitor parent, final ClassContext context) {
+        return new MethodVisitor(api, parent) {
+            @Override
+            public void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+                if (MethodRewriteRule.this.owner().test(owner) && MethodRewriteRule.this.nameAndDesc().test(name, descriptor)) {
+                    final @Nullable Rewrite rewrite = MethodRewriteRule.this.rewrite(context, opcode, owner, name, descriptor, isInterface);
+                    if (rewrite != null) {
+                        super.visitMethodInsn(rewrite.opcode, rewrite.owner, rewrite.name, rewrite.descriptor, rewrite.isInterface);
+                        return;
+                    }
+                }
+                super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+            }
+
+            @Override
+            public void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {
+                if (LAMBDA_METAFACTORY_OWNER.equals(bootstrapMethodHandle.getOwner()) && bootstrapMethodArguments.length > 1 && bootstrapMethodArguments[1] instanceof Handle handle) {
+                    if (MethodRewriteRule.this.owner().test(handle.getOwner()) && MethodRewriteRule.this.nameAndDesc().test(handle.getName(), handle.getDesc())) {
+                        final @Nullable Rewrite rewrite = MethodRewriteRule.this.rewrite(context, handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());
+                        if (rewrite != null) {
+                            bootstrapMethodArguments[1] = new Handle(rewrite.opcode, rewrite.owner, rewrite.name, rewrite.descriptor, rewrite.isInterface);
+                        }
+                    }
+                }
+                super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
+            }
+        };
+    }
+
+    @Nullable Rewrite rewrite(ClassContext context, int opcode, String owner, String name, String descriptor, boolean isInterface);
+
+    record Rewrite(int opcode, String owner, String name, String descriptor, boolean isInterface) {}
+
+    @FunctionalInterface
+    interface NameAndDescPredicate {
+
+        boolean test(String name, String desc);
+
+        default NameAndDescPredicate and(final NameAndDescPredicate other) {
+            return (name, desc) -> this.test(name, desc) && other.test(name, desc);
+        }
+
+        default NameAndDescPredicate or(final NameAndDescPredicate other) {
+            return (name, desc) -> this.test(name, desc) || other.test(name, desc);
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..50d9d93aa967bc9ca933e1ae0bcd0b30f9916ed0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder.RuleFactory;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Consumer;
+import org.objectweb.asm.MethodVisitor;
+
+public interface RewriteRule {
+
+    static RewriteRule forOwner(final Class<?> owner, final Consumer<? super RuleFactory> factoryConsumer) {
+        return forOwners(Collections.singleton(owner), factoryConsumer);
+    }
+
+    static RewriteRule forOwners(final Set<Class<?>> owners, final Consumer<? super RuleFactory> factoryConsumer) {
+        final RuleFactory factory = RuleFactory.create(owners);
+        factoryConsumer.accept(factory);
+        return factory.build();
+    }
+
+    static RewriteRule chain(final RewriteRule... rules) {
+        return chain(Arrays.asList(rules));
+    }
+
+    static RewriteRule chain(final List<? extends RewriteRule> rules) {
+        return new Chain(List.copyOf(rules));
+    }
+
+    MethodVisitor createVisitor(int api, MethodVisitor parent, final ClassContext context);
+
+    final class Chain implements RewriteRule {
+
+        private final List<RewriteRule> rules;
+
+        private Chain(final List<RewriteRule> rules) {
+            this.rules = rules;
+        }
+
+        @Override
+        public MethodVisitor createVisitor(final int api, final MethodVisitor parent, final ClassContext context) {
+            MethodVisitor visitor = parent;
+            for (final RewriteRule rule : this.rules) {
+                visitor = rule.createVisitor(api, visitor, context);
+            }
+            return visitor;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java
new file mode 100644
index 0000000000000000000000000000000000000000..19f802ea05bcaa7e24455776b41b2b97441006f6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.Opcodes;
+
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.DescriptorUtils.fromOwner;
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.DescriptorUtils.toOwner;
+
+public interface StaticRewrite extends MethodRewriteRule {
+
+    ClassDesc newOwner();
+
+    default MethodTypeDesc modifyMethodDescriptor(final MethodTypeDesc methodDescriptor) {
+        return methodDescriptor;
+    }
+
+    @Override
+    default @Nullable Rewrite rewrite(final ClassContext context, final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(descriptor);
+        if (opcode == Opcodes.INVOKEVIRTUAL || opcode == Opcodes.INVOKEINTERFACE) { // insert owner object as first param
+            desc = desc.insertParameterTypes(0, fromOwner(owner));
+        }
+        return new Rewrite(Opcodes.INVOKESTATIC, toOwner(this.newOwner()), name, this.modifyMethodDescriptor(desc).descriptorString(), false);
+    }
+
+    record Plain(Predicate<String> owner, NameAndDescPredicate nameAndDesc, ClassDesc newOwner) implements StaticRewrite {
+    }
+
+    record FuzzyParam(Predicate<String> owner, NameAndDescPredicate nameAndDesc, ClassDesc newOwner, Predicate<ClassDesc> fuzzyParam) implements StaticRewrite {
+
+        private static final ClassDesc OBJECT = ClassDesc.of(Object.class.getName());
+
+        @Override
+        public MethodTypeDesc modifyMethodDescriptor(MethodTypeDesc methodDescriptor) {
+            for (int i = 0; i < methodDescriptor.parameterCount(); i++) {
+                if (this.fuzzyParam().test(methodDescriptor.parameterType(i))) {
+                    methodDescriptor = methodDescriptor.changeParameterType(i, OBJECT);
+                }
+            }
+            return methodDescriptor;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..87f0989d02ec34522fc8459d286ad669e16593b9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java
@@ -0,0 +1,100 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.MethodRewriteRule;
+import java.lang.constant.MethodTypeDesc;
+import java.util.Set;
+import java.util.function.Predicate;
+
+public final class MethodMatcher {
+    private final Predicate<String> anyDescriptor;
+    private final Predicate<String> anyName;
+    private final MethodRewriteRule.NameAndDescPredicate nameAndDesc;
+
+    private MethodMatcher(final Predicate<String> anyDescriptor, final Predicate<String> anyName, final MethodRewriteRule.NameAndDescPredicate nameAndDesc) {
+        this.anyDescriptor = anyDescriptor;
+        this.anyName = anyName;
+        this.nameAndDesc = nameAndDesc;
+    }
+
+    public boolean matches(final String name, final String descriptor) {
+        return this.anyName.test(name) || this.anyDescriptor.test(descriptor) || this.nameAndDesc.test(name, descriptor);
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static final class Builder {
+        private Predicate<String> anyDescriptor = s -> false;
+        private Predicate<String> anyName = s -> false;
+        private MethodRewriteRule.NameAndDescPredicate nameAndDesc = (n, d) -> false;
+
+        private Builder() {
+        }
+
+        public Builder matchAnyName(final String desc) {
+            this.anyName = this.anyName.or(s -> s.equals(desc));
+            return this;
+        }
+
+        public Builder matchAnyDesc(final String...names) {
+            for (final String name : names) {
+                this.anyDescriptor = this.anyDescriptor.or(s -> s.equals(name));
+            }
+            return this;
+        }
+
+        public Builder match(final String name, final Predicate<? super MethodTypeDesc> descPredicate) {
+            return this.match(n -> n.equals(name), descPredicate);
+        }
+
+        public Builder match(final Set<String> names, final Predicate<? super MethodTypeDesc> descPredicate) {
+            return this.match(names::contains, descPredicate);
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final String descriptor) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && d.equals(descriptor));
+            return this;
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final Set<String> descriptors) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && descriptors.contains(d));
+            return this;
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final Predicate<? super MethodTypeDesc> descPredicate) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && descPredicate.test(MethodTypeDesc.ofDescriptor(d)));
+            return this;
+        }
+
+        public Builder match(final String name, final String desc) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> n.equals(name) && d.equals(desc));
+            return this;
+        }
+
+        public Builder match(final String name, final Set<String> descs) {
+            for (final String s : descs) {
+                this.match(name, s);
+            }
+            return this;
+        }
+
+        public Builder match(final Set<String> names, final String desc) {
+            for (final String name : names) {
+                this.match(name, desc);
+            }
+            return this;
+        }
+
+        public Builder match(final Set<String> names, final Set<String> descs) {
+            for (final String name : names) {
+                this.match(name, descs);
+            }
+            return this;
+        }
+
+        public MethodMatcher build() {
+            return new MethodMatcher(this.anyDescriptor, this.anyName, this.nameAndDesc);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..069084bdd3c33c2ab8e02a6662e5aa686f58be38
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import java.util.Set;
+import java.util.function.Consumer;
+
+public interface RuleFactory {
+
+    static RuleFactory create(final Set<Class<?>> owners) {
+        return new RuleFactoryImpl(owners);
+    }
+
+    private static MethodMatcher runBuilderConsumer(final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        final MethodMatcher.Builder builder = MethodMatcher.builder();
+        builderConsumer.accept(builder);
+        return builder.build();
+    }
+
+    default void changeParam(final Class<?> oldParam, final Class<?> newParam, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.changeParam(oldParam, newParam, runBuilderConsumer(builderConsumer));
+    }
+
+    void changeParam(Class<?> oldParam, Class<?> newParam, MethodMatcher matcher);
+
+    default void changeReturnType(final Class<?> oldReturnType, final Class<?> newReturnType, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.changeReturnType(oldReturnType, newReturnType, runBuilderConsumer(builderConsumer));
+    }
+
+    void changeReturnType(Class<?> oldReturnType, Class<?> newReturnType, MethodMatcher matcher);
+
+    default void plainStaticRewrite(final Class<?> newOwner, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.plainStaticRewrite(newOwner, runBuilderConsumer(builderConsumer));
+    }
+
+    void plainStaticRewrite(Class<?> newOwner, MethodMatcher matcher);
+
+    default void fuzzyStaticRewrite(final Class<?> newOwner, final Class<?> fuzzyParameter, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.fuzzyStaticRewrite(newOwner, fuzzyParameter, runBuilderConsumer(builderConsumer));
+    }
+
+    void fuzzyStaticRewrite(Class<?> newOwner, Class<?> fuzzyParameter, MethodMatcher matcher);
+
+    RewriteRule build();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..43e9f9f34210c36a700dfd3a9090880b6f7961e6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.DescriptorUtils;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.ChangeParameter;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.ChangeReturnType;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.StaticRewrite;
+import java.lang.constant.ClassDesc;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+final class RuleFactoryImpl implements RuleFactory {
+
+    final Set<String> owners;
+    final List<RewriteRule> rules = new ArrayList<>();
+
+    RuleFactoryImpl(final Set<Class<?>> owners) {
+        this.owners = owners.stream().map(c -> DescriptorUtils.toOwner(c.describeConstable().orElseThrow())).collect(Collectors.toUnmodifiableSet());
+    }
+
+    @Override
+    public void changeParam(final Class<?> oldParam, final Class<?> newParam, final MethodMatcher matcher) {
+        this.rules.add(new ChangeParameter(this.owners::contains, matcher::matches, ClassDesc.of(oldParam.getName()), ClassDesc.of(newParam.getName())));
+    }
+
+    @Override
+    public void changeReturnType(final Class<?> oldReturnType, final Class<?> newReturnType, final MethodMatcher matcher) {
+        this.rules.add(new ChangeReturnType(this.owners::contains, matcher::matches, ClassDesc.of(oldReturnType.getName()), ClassDesc.of(newReturnType.getName())));
+    }
+
+    @Override
+    public void plainStaticRewrite(final Class<?> newOwner, final MethodMatcher matcher) {
+        this.rules.add(new StaticRewrite.Plain(this.owners::contains, matcher::matches, ClassDesc.of(newOwner.getName())));
+    }
+
+    @Override
+    public void fuzzyStaticRewrite(final Class<?> newOwner, final Class<?> fuzzyParameter, final MethodMatcher matcher) {
+        this.rules.add(new StaticRewrite.FuzzyParam(this.owners::contains, matcher::matches, newOwner.describeConstable().orElseThrow(), d -> d.equals(fuzzyParameter.describeConstable().orElseThrow())));
+    }
+
+    @Override
+    public RewriteRule build() {
+        return RewriteRule.chain(this.rules);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java
new file mode 100644
index 0000000000000000000000000000000000000000..928c440437953903bcdea6e7c44210f476863bd0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java
@@ -0,0 +1,166 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.versions;
+
+import com.destroystokyo.paper.event.executor.asm.ClassDefiner;
+import io.papermc.paper.math.Position;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.VersionedClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import io.papermc.paper.plugin.loader.PaperClasspathBuilder;
+import it.unimi.dsi.fastutil.Pair;
+import it.unimi.dsi.fastutil.ints.IntArraySet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.World;
+import org.bukkit.block.SculkCatalyst;
+import org.bukkit.block.Sign;
+import org.bukkit.boss.DragonBattle;
+import org.bukkit.entity.Player;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.commons.GeneratorAdapter;
+
+public class API_1_20_2 extends VersionedClassloaderBytecodeModifier {
+
+    private static final ClassDesc POSITION = ClassDesc.of(Position.class.getName());
+    private static final ClassDesc OBJECT = Object.class.describeConstable().orElseThrow();
+    private static final String POSITION_DELEGATES_CLASS_NAME = "io.papermc.paper.plugin.bytecode.generated.API_1_20_PositionDelegates";
+    private static final Class<?> POSITION_DELEGATES;
+
+    static final List<Pair<Set<Class<?>>, Set<String>>> SIMPLE_POSITION_CHANGES = List.of(
+        Pair.of(Set.of(Bukkit.class, Server.class), Set.of("isOwnedByCurrentRegion")),
+        Pair.of(Set.of(World.class), Set.of("rayTraceEntities", "rayTraceBlocks", "rayTrace")),
+        Pair.of(Set.of(SculkCatalyst.class), Set.of("bloom")),
+        Pair.of(Set.of(Sign.class), Set.of("getInteractableSideFor")),
+        Pair.of(Set.of(DragonBattle.class), Set.of("spawnNewGateway")),
+        Pair.of(Set.of(Player.class), Set.of("lookAt"))
+    );
+
+    static {
+        try {
+            final ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+            writer.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, POSITION_DELEGATES_CLASS_NAME.replace('.', '/'), null, Type.getInternalName(Object.class), null);
+            for (final Pair<Set<Class<?>>, Set<String>> pair : SIMPLE_POSITION_CHANGES) {
+                for (final Class<?> ownerClass : pair.first()) {
+                    for (final Method method : ownerClass.getMethods()) {
+                        if (pair.second().contains(method.getName()) && Arrays.asList(method.getParameterTypes()).contains(Position.class)) {
+                            final MethodType type = MethodType.methodType(method.getReturnType(), method.getParameterTypes());
+                            MethodTypeDesc methodDescriptor = type.describeConstable().orElseThrow();
+                            if (!Modifier.isStatic(method.getModifiers())) {
+                                methodDescriptor = methodDescriptor.insertParameterTypes(0, ownerClass.describeConstable().orElseThrow());
+                            }
+                            final IntSet positions = new IntArraySet();
+                            for (int i = 0; i < methodDescriptor.parameterCount(); i++) {
+                                if (methodDescriptor.parameterType(i).equals(POSITION)) {
+                                    methodDescriptor.changeParameterType(i, OBJECT);
+                                    positions.add(i);
+                                }
+                            }
+                            final MethodVisitor methodVisitor = writer.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, method.getName(), methodDescriptor.descriptorString(), null, null);
+                            final GeneratorAdapter methodGenerator = new GeneratorAdapter(methodVisitor, Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, method.getName(), methodDescriptor.descriptorString());
+                            for (int i = 0; i < methodDescriptor.parameterCount(); i++) {
+                                methodGenerator.loadArg(i);
+                                if (positions.contains(i)) {
+                                    methodGenerator.invokeStatic(Type.getType(API_1_20_2.class), org.objectweb.asm.commons.Method.getMethod(API_1_20_2.class.getDeclaredMethod("toPos", Object.class)));
+                                }
+                            }
+                            if (ownerClass.isInterface() && !Modifier.isStatic(method.getModifiers())) {
+                                methodGenerator.invokeInterface(Type.getType(ownerClass), org.objectweb.asm.commons.Method.getMethod(method));
+                            } else if (!ownerClass.isInterface() && !Modifier.isStatic(method.getModifiers())) {
+                                methodGenerator.invokeVirtual(Type.getType(ownerClass), org.objectweb.asm.commons.Method.getMethod(method));
+                            } else {
+                                methodGenerator.invokeStatic(Type.getType(ownerClass), org.objectweb.asm.commons.Method.getMethod(method));
+                            }
+                            methodGenerator.returnValue();
+                            methodGenerator.endMethod();
+                            writer.visitEnd();
+                        }
+                    }
+                }
+            }
+            POSITION_DELEGATES = ClassDefiner.getInstance().defineClass(PaperClasspathBuilder.class.getClassLoader(), POSITION_DELEGATES_CLASS_NAME, writer.toByteArray());
+        } catch (final Throwable throwable) {
+            throw new RuntimeException("Could not define helper class " + POSITION_DELEGATES_CLASS_NAME, throwable);
+        }
+            // }
+    }
+
+    public API_1_20_2(final int api) {
+        super(api);
+    }
+
+    // private final ThreadLocal<ClassLoader> currentLoader = new ThreadLocal<>();
+
+    @Override
+    public byte[] modify(final ClassLoader classLoader, final PluginMeta config, final byte[] bytecode) {
+        // this.currentLoader.set(classLoader);
+        final ClassReader cr = new ClassReader(bytecode);
+        final ClassWriter cw = new ClassWriter(cr, 0);
+        this.cv = cw;
+
+        cr.accept(this, 0);
+        return cw.toByteArray();
+    }
+
+    @Override
+    public MethodVisitor visitMethod(final int access, final String name, final String descriptor, final String signature, final String[] exceptions) {
+        final RewriteRule rule = RewriteRule.chain(SIMPLE_POSITION_CHANGES.stream().map(pair -> {
+            return removePositionFromLocation(POSITION_DELEGATES, pair.left(), pair.right());
+        }).collect(Collectors.toList()));
+        // final RewriteRule rule = RewriteRule.forOwners(Set.of("org/bukkit/Bukkit", "org/bukkit/Server"), factory -> {
+        //     factory.fuzzyStaticRewrite(API_1_20_2.class, Position.class, m -> m.match("isOwnedByCurrentRegion", d -> d.parameterList().contains(POSITION)));
+        // });
+        return rule.createVisitor(this.api, super.visitMethod(access, name, descriptor, signature, exceptions), this);
+    }
+
+    private static RewriteRule removePositionFromLocation(final Class<?> newOwner, final Set<Class<?>> owners, final Set<String> methodNames) {
+        return RewriteRule.forOwners(owners, factory -> {
+            factory.fuzzyStaticRewrite(newOwner, Position.class, m -> m.match(methodNames, d -> d.parameterList().contains(POSITION)));
+        });
+    }
+
+    public static Position toPos(final Object object) {
+        return object instanceof final Location loc ? loc.asPosition() : (Position) object;
+    }
+    //
+    // public static boolean isOwnedByCurrentRegion(final World world, final Object position) {
+    //     return isOwnedByCurrentRegion(Bukkit.getServer(), world, position);
+    // }
+    //
+    // public static boolean isOwnedByCurrentRegion(final Server server, final World world, final Object position) {
+    //     return server.isOwnedByCurrentRegion(world, toPos(position));
+    // }
+    //
+    // public static @Nullable RayTraceResult rayTraceEntities(final World world, final Object start, final Vector direction, final double maxDistance, final double raySize, final @Nullable Predicate<Entity> filter) {
+    //     return world.rayTraceEntities(toPos(start), direction, maxDistance, raySize, filter);
+    // }
+    //
+    // public static @Nullable RayTraceResult rayTraceBlocks(final World world, final Object start, final Vector direction, final double maxDistance, final FluidCollisionMode fluidCollisionMode, final boolean ignorePassableBlocks, final @Nullable Predicate<Block> canCollide) {
+    //     return world.rayTraceBlocks(toPos(start), direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, canCollide);
+    // }
+    //
+    // public static @Nullable RayTraceResult rayTrace(final World world, final Object start, final Vector direction, final double maxDistance, final FluidCollisionMode fluidCollisionMode, final boolean ignorePassableBlocks, final double raySize, final @Nullable Predicate<Entity> filter, final @Nullable Predicate<Block> canCollide) {
+    //     return world.rayTrace(toPos(start), direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, raySize, filter, canCollide);
+    // }
+    //
+    // public static void bloom(final SculkCatalyst sculkCatalyst, final Object position, final int charge) {
+    //     sculkCatalyst.bloom(toPos(position), charge);
+    // }
+    //
+    // public static Side getInteractableSideFor(final Sign sign, final Object position) {
+    //     return sign.getInteractableSideFor(toPos(position));
+    // }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
index 2e02f73b857c530a0cce3a8d6aae46e3b0966486..f6566a2fca2f4aa0b281f525e0aa6f8b0ef966f2 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
@@ -1,6 +1,7 @@
 package io.papermc.paper.plugin.provider.configuration.serializer.constraints;
 
 import io.papermc.paper.plugin.util.NamespaceChecker;
+import java.util.List;
 import org.spongepowered.configurate.objectmapping.meta.Constraint;
 import org.spongepowered.configurate.serialize.SerializationException;
 
@@ -17,7 +18,18 @@ import java.util.regex.Pattern;
 public final class PluginConfigConstraints {
 
     public static final Set<String> RESERVED_KEYS = Set.of("bukkit", "minecraft", "mojang", "spigot", "paper");
-    public static final Set<String> VALID_PAPER_VERSIONS = Set.of("1.19", "1.20");
+    public static final List<String> VALID_PAPER_VERSIONS = List.of(
+        //<editor-fold desc="API Versions" defaultstate="collapsed">
+        "1.19",
+        "1.19.1",
+        "1.19.2",
+        "1.19.3",
+        "1.19.4",
+        "1.20",
+        "1.20.1",
+        "1.20.2"
+        //</editor-fold>
+    );
 
     @Documented
     @Retention(RetentionPolicy.RUNTIME)
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index c3060d1d4d0caf369c6ab516cb424f45eb851019..ecd79b639a76bb689bfa7119051c68d7491d9856 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -1119,7 +1119,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
         // Paper start
-        return rayTraceEntities((io.papermc.paper.math.Position) start, direction, maxDistance, raySize, filter);
+        return rayTraceEntities(start.asPosition(), direction, maxDistance, raySize, filter);
     }
 
     public RayTraceResult rayTraceEntities(io.papermc.paper.math.Position start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
@@ -1177,7 +1177,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
         // Paper start
-        return this.rayTraceBlocks(start, direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, null);
+        return this.rayTraceBlocks(start.asPosition(), direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, null);
     }
 
     @Override
@@ -1208,7 +1208,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
         // Paper start
-        return this.rayTrace(start, direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, raySize, filter, null);
+        return this.rayTrace(start.asPosition(), direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, raySize, filter, null);
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
index 6eae6efa35a1ccc224e2f311e25ecf13e8647ec8..049adcf0dd7df6616965b035b40b216bd0cf7944 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
@@ -87,7 +87,7 @@ public class CraftEnderDragon extends CraftMob implements EnderDragon, CraftEnem
             this.getHandle().setPodium(null);
         } else {
             org.apache.commons.lang.Validate.isTrue(location.getWorld() == null || location.getWorld().equals(getWorld()), "You cannot set a podium in a different world to where the dragon is");
-            this.getHandle().setPodium(io.papermc.paper.util.MCUtil.toBlockPos(location));
+            this.getHandle().setPodium(io.papermc.paper.util.MCUtil.toBlockPos(location.asPosition()));
         }
     }
     // Paper end
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 83aaf3e6e377d731ce02f779f80b7bf5db46f89f..edd874ce68cc6e7227d60153d0e553c8b37ebc75 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1242,7 +1242,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         org.bukkit.util.Vector direction = targetLocation.getDirection();
         direction.multiply(9999999); // We need to move the target block.. FAR out
         targetLocation.add(direction);
-        this.lookAt(targetLocation, io.papermc.paper.entity.LookAnchor.EYES);
+        this.lookAt(targetLocation.asPosition(), io.papermc.paper.entity.LookAnchor.EYES);
         // Paper end
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 548c77592a3520e8053483644eba805079a14f1a..296c256862109028a27d678f1941f7d707c27636 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -3,7 +3,6 @@ package org.bukkit.craftbukkit.util;
 import com.google.common.base.Charsets;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMultimap;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.io.Files;
 import com.google.gson.JsonElement;
@@ -13,7 +12,6 @@ import com.mojang.serialization.Dynamic;
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
@@ -405,9 +403,10 @@ public final class CraftMagicNumbers implements UnsafeValues {
     }
 
     @Override
-    public byte[] processClass(PluginDescriptionFile pdf, String path, byte[] clazz) {
+    public byte[] processClass(ClassLoader classLoader, PluginDescriptionFile pdf, String path, byte[] clazz) {
         try {
             clazz = Commodore.convert(clazz, !CraftMagicNumbers.isLegacy(pdf));
+            clazz = io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier.bytecodeModifier().modify(classLoader, pdf, clazz); // Paper - run plugins through our modifications as well
         } catch (Exception ex) {
             Bukkit.getLogger().log(Level.SEVERE, "Fatal error trying to convert " + pdf.getFullName() + ":" + path, ex);
         }
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier b/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
index 20dbe2775951bfcdb85c5d679ac86c77a93e0847..4a554839971953e6f2b19e674d68afb727a39adf 100644
--- a/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
+++ b/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
@@ -1 +1 @@
-io.papermc.paper.plugin.entrypoint.classloader.PaperClassloaderBytecodeModifier
+io.papermc.paper.plugin.entrypoint.classloader.bytecode.PaperClassloaderBytecodeModifier
