From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Sun, 12 Nov 2023 16:56:03 -0800
Subject: [PATCH] work on bytecode modifier


diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java
deleted file mode 100644
index f9a2c55a354c877749db3f92956de802ae575788..0000000000000000000000000000000000000000
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package io.papermc.paper.plugin.entrypoint.classloader;
-
-import io.papermc.paper.plugin.configuration.PluginMeta;
-
-// Stub, implement in future.
-public class PaperClassloaderBytecodeModifier implements ClassloaderBytecodeModifier {
-
-    @Override
-    public byte[] modify(PluginMeta configuration, byte[] bytecode) {
-        return bytecode;
-    }
-}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..d5e3e2ec145de0af3de12460aa5acef6ba4b5f60
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public interface ClassContext {
+
+    String className();
+
+    @Nullable String superClassName();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..20d32a9bd1bc68e54904d2105495a60bd3e856bf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java
@@ -0,0 +1,35 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import java.lang.constant.ClassDesc;
+import java.lang.constant.ConstantDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Executable;
+import java.lang.reflect.Method;
+
+public final class DescriptorUtils {
+
+    public static ClassDesc fromOwner(final String owner) {
+        return ClassDesc.ofDescriptor("L" + owner + ";");
+    }
+
+    public static String toOwner(final ClassDesc desc) {
+        final String descriptor = desc.descriptorString();
+        return descriptor.substring(1, descriptor.length() - 1);
+    }
+
+    public static MethodTypeDesc fromExecutable(final Executable executable) {
+        final org.objectweb.asm.commons.Method asmMethod;
+        if (executable instanceof final Method method) {
+            asmMethod = org.objectweb.asm.commons.Method.getMethod(method);
+        } else if (executable instanceof final Constructor<?> constructor) {
+            asmMethod = org.objectweb.asm.commons.Method.getMethod(constructor);
+        } else {
+            throw new IllegalArgumentException(executable + " isn't a constructor or method");
+        }
+        return MethodTypeDesc.ofDescriptor(asmMethod.getDescriptor());
+    }
+
+    private DescriptorUtils() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b98d47f108956a39b75bbccb43507167c59a855
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import com.google.common.collect.Iterators;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.versions.API_1_20_2;
+import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import net.minecraft.Util;
+import org.objectweb.asm.Opcodes;
+
+public class PaperClassloaderBytecodeModifier implements ClassloaderBytecodeModifier {
+
+    static final Map<String, ModifierFactory> MODIFIERS = Util.make(new LinkedHashMap<>(), map -> {
+        map.put("1.20.2", API_1_20_2::new);
+    });
+
+    @Override
+    public byte[] modify(final PluginMeta configuration, byte[] bytecode) {
+        int start = -1;
+        if (configuration.getAPIVersion() != null) {
+            int i = 0;
+            for (final Map.Entry<String, ModifierFactory> entry : MODIFIERS.entrySet()) {
+                final int pluginIdx = PluginConfigConstraints.VALID_PAPER_VERSIONS.indexOf(configuration.getAPIVersion());
+                final int modifierIdx = PluginConfigConstraints.VALID_PAPER_VERSIONS.indexOf(entry.getKey());
+                if (pluginIdx <= modifierIdx) {
+                    start = i;
+                    break;
+                }
+                i++;
+            }
+        } else {
+            start = 0;
+        }
+        if (start == -1) {
+            return bytecode; // no modification needed. The plugin version is newer than all versioned modifiers
+        }
+
+        final Iterator<Map.Entry<String, ModifierFactory>> iter = MODIFIERS.entrySet().iterator();
+        Iterators.advance(iter, start);
+        while (iter.hasNext()) {
+            final VersionedClassloaderBytecodeModifier modifier = iter.next().getValue().create(Opcodes.ASM9);
+            bytecode = modifier.modify(configuration, bytecode);
+        }
+        return bytecode;
+    }
+
+    private interface ModifierFactory {
+
+        VersionedClassloaderBytecodeModifier create(int api);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..75c594ee4bf30e33ffe44661b8971b5c6223f0ac
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java
@@ -0,0 +1,56 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import java.lang.invoke.MethodHandles;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.commons.GeneratorAdapter;
+
+public abstract class VersionedClassloaderBytecodeModifier extends ClassVisitor implements ClassloaderBytecodeModifier, ClassContext {
+
+    private @MonotonicNonNull String className;
+    private @Nullable String superClassName;
+
+    protected VersionedClassloaderBytecodeModifier(final int api) {
+        super(api);
+    }
+
+    @Override
+    public void visit(final int version, final int access, final String name, final @Nullable String signature, final @Nullable String superName, final String @Nullable [] interfaces) {
+        super.visit(version, access, name, signature, superName, interfaces);
+        this.className = name;
+        this.superClassName = superName;
+    }
+
+    @Override
+    public String className() {
+        return this.className;
+    }
+
+    @Override
+    public @Nullable String superClassName() {
+        return this.superClassName;
+    }
+
+    protected static Class<?> defineGeneratedDelegates(final Class<? extends VersionedClassloaderBytecodeModifier> versionedClass, final RewriteRule finalRule) {
+        final String className = versionedClass.getName() + "_GeneratedDelegates";
+        final ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+        writer.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, className.replace('.', '/'), null, Type.getInternalName(Object.class), null);
+        finalRule.generateMethods((access, name, descriptor) -> {
+            final MethodVisitor methodVisitor = writer.visitMethod(access, name, descriptor, null, null);
+            return new GeneratorAdapter(methodVisitor, access, name, descriptor);
+        });
+        writer.visitEnd();
+        try {
+            return MethodHandles.privateLookupIn(versionedClass, MethodHandles.lookup()).defineClass(writer.toByteArray());
+        } catch (final IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..f63c305dff1e754cdaea4f0f8055ed850eab6d5a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4df6c2bcd9768f745f4fc9967e4a2d380a1892e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.util.Set;
+
+public record ChangeParameter(Set<Class<?>> owners, NameAndDescPredicate nameAndDesc, ClassDesc oldParam, ClassDesc newParam) implements MethodRewriteRule {
+
+    @Override
+    public Rewrite rewrite(final ClassContext context, final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+        return new Rewrite(opcode, owner, name, this.replaceParameter(descriptor), isInterface);
+    }
+
+    private String replaceParameter(final String initialDescriptor) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(initialDescriptor);
+        final ClassDesc[] parameterArray = desc.parameterArray();
+        for (int i = 0; i < parameterArray.length; i++) {
+            final ClassDesc classDesc = parameterArray[i];
+            if (classDesc.equals(ChangeParameter.this.oldParam())) {
+                desc = desc.changeParameterType(i, ChangeParameter.this.newParam());
+            }
+        }
+        return desc.descriptorString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java
new file mode 100644
index 0000000000000000000000000000000000000000..86710ef2fe07aca9c457ecd2a2b97b7cb30aae09
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java
@@ -0,0 +1,27 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.util.Set;
+
+/**
+ * Using this type requires that the actual type of the returned value not be changed so a cast
+ * will still succeed. This is significantly simpler than trying to handle actually changing
+ * the type.
+ */
+public record ChangeReturnType(Set<Class<?>> owners, NameAndDescPredicate nameAndDesc, ClassDesc oldReturn, ClassDesc newReturn) implements MethodRewriteRule {
+
+    @Override
+    public Rewrite rewrite(final ClassContext context, final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+        return new Rewrite(opcode, owner, name, this.replaceReturnType(descriptor), isInterface);
+    }
+
+    private String replaceReturnType(final String initialDescriptor) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(initialDescriptor);
+        if (desc.returnType().equals(this.oldReturn())) {
+            desc = desc.changeReturnType(this.newReturn());
+        }
+        return desc.descriptorString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..554d9a2e171c446af86e060bba66094aabed1636
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java
@@ -0,0 +1,91 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import it.unimi.dsi.fastutil.Pair;
+import java.lang.constant.MethodTypeDesc;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Executable;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Type;
+
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.DescriptorUtils.fromExecutable;
+
+public interface MethodRewriteRule extends RewriteRule {
+
+    String LAMBDA_METAFACTORY_OWNER = "java/lang/invoke/LambdaMetafactory";
+
+    Set<Class<?>> owners();
+
+    default boolean matchesOwner(final String owner) {
+        return this.owners().stream().map(Type::getInternalName).anyMatch(Predicate.isEqual(owner));
+    }
+
+    NameAndDescPredicate nameAndDesc();
+
+    @Override
+    default MethodVisitor createVisitor(final int api, final MethodVisitor parent, final ClassContext context) {
+        return new MethodVisitor(api, parent) {
+            @Override
+            public void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+                if (MethodRewriteRule.this.matchesOwner(owner) && MethodRewriteRule.this.nameAndDesc().test(name, descriptor)) {
+                    final @Nullable Rewrite rewrite = MethodRewriteRule.this.rewrite(context, opcode, owner, name, descriptor, isInterface);
+                    if (rewrite != null) {
+                        super.visitMethodInsn(rewrite.opcode, rewrite.owner, rewrite.name, rewrite.descriptor, rewrite.isInterface);
+                        return;
+                    }
+                }
+                super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+            }
+
+            @Override
+            public void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {
+                if (LAMBDA_METAFACTORY_OWNER.equals(bootstrapMethodHandle.getOwner()) && bootstrapMethodArguments.length > 1 && bootstrapMethodArguments[1] instanceof Handle handle) {
+                    if (MethodRewriteRule.this.matchesOwner(handle.getOwner()) && MethodRewriteRule.this.nameAndDesc().test(handle.getName(), handle.getDesc())) {
+                        final @Nullable Rewrite rewrite = MethodRewriteRule.this.rewrite(context, handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());
+                        if (rewrite != null) {
+                            bootstrapMethodArguments[1] = new Handle(rewrite.opcode, rewrite.owner, rewrite.name, rewrite.descriptor, rewrite.isInterface);
+                        }
+                    }
+                }
+                super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
+            }
+        };
+    }
+
+    default Stream<Pair<Executable, MethodTypeDesc>> matchingMethods() {
+        return this.owners().stream()
+            .flatMap(o -> Stream.concat(Arrays.stream(o.getMethods()), Arrays.stream(o.getConstructors())))
+            .map(executable -> Pair.of(executable, fromExecutable(executable)))
+            .filter(pair -> this.nameAndDesc().test(transformExecutableName(pair.left()), pair.right().descriptorString()));
+    }
+
+    private static String transformExecutableName(final Executable executable) {
+        return executable instanceof Constructor<?> ? "<init>" : executable.getName();
+    }
+
+    @Nullable Rewrite rewrite(ClassContext context, int opcode, String owner, String name, String descriptor, boolean isInterface);
+
+    record Rewrite(int opcode, String owner, String name, String descriptor, boolean isInterface) {}
+
+    @FunctionalInterface
+    interface NameAndDescPredicate {
+
+        boolean test(String name, String desc);
+
+        default NameAndDescPredicate and(final NameAndDescPredicate other) {
+            return (name, desc) -> this.test(name, desc) && other.test(name, desc);
+        }
+
+        default NameAndDescPredicate or(final NameAndDescPredicate other) {
+            return (name, desc) -> this.test(name, desc) || other.test(name, desc);
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..7e4e5f30101ec8d62e07b0e119de8b0b9e86fc8a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder.RuleFactory;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Consumer;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.commons.GeneratorAdapter;
+
+public interface RewriteRule {
+
+    static RewriteRule forOwner(final Class<?> owner, final Consumer<? super RuleFactory> factoryConsumer) {
+        return forOwners(Collections.singleton(owner), factoryConsumer);
+    }
+
+    static RewriteRule forOwners(final Set<Class<?>> owners, final Consumer<? super RuleFactory> factoryConsumer) {
+        final RuleFactory factory = RuleFactory.create(owners);
+        factoryConsumer.accept(factory);
+        return factory.build();
+    }
+
+    static RewriteRule chain(final RewriteRule... rules) {
+        return chain(Arrays.asList(rules));
+    }
+
+    static RewriteRule chain(final List<? extends RewriteRule> rules) {
+        return new Chain(List.copyOf(rules));
+    }
+
+    MethodVisitor createVisitor(int api, MethodVisitor parent, final ClassContext context);
+
+    default void generateMethods(final MethodGeneratorFactory methodGeneratorFactory) {
+    }
+
+    @FunctionalInterface
+    interface MethodGeneratorFactory {
+        GeneratorAdapter create(int access, String name, String descriptor);
+    }
+
+    final class Chain implements RewriteRule {
+
+        private final List<RewriteRule> rules;
+
+        private Chain(final List<RewriteRule> rules) {
+            this.rules = rules;
+        }
+
+        @Override
+        public MethodVisitor createVisitor(final int api, final MethodVisitor parent, final ClassContext context) {
+            MethodVisitor visitor = parent;
+            for (final RewriteRule rule : this.rules) {
+                visitor = rule.createVisitor(api, visitor, context);
+            }
+            return visitor;
+        }
+
+        @Override
+        public void generateMethods(final MethodGeneratorFactory methodGeneratorFactory) {
+            this.rules.forEach(rule -> rule.generateMethods(methodGeneratorFactory));
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d406c0b2dc7f10b33d9110dc5374a9d526c6b23
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java
@@ -0,0 +1,143 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import it.unimi.dsi.fastutil.ints.IntArraySet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.commons.GeneratorAdapter;
+
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.DescriptorUtils.fromOwner;
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.DescriptorUtils.toOwner;
+
+public interface StaticRewrite extends MethodRewriteRule {
+
+    ClassDesc newOwner();
+
+    default MethodTypeDesc modifyMethodDescriptor(final MethodTypeDesc methodDescriptor) {
+        return methodDescriptor;
+    }
+
+    @Override
+    default @Nullable Rewrite rewrite(final ClassContext context, final int opcode, final String owner, String name, final String descriptor, final boolean isInterface) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(descriptor);
+        if (opcode == Opcodes.INVOKEVIRTUAL || opcode == Opcodes.INVOKEINTERFACE) { // insert owner object as first param
+            desc = desc.insertParameterTypes(0, fromOwner(owner));
+        } else if (opcode == Opcodes.INVOKESPECIAL) {
+            if ("<init>".equals(name)) {
+                name = "create" + owner.substring(owner.lastIndexOf('/') + 1);
+                desc = desc.changeReturnType(fromOwner(owner));
+            } else {
+                throw new UnsupportedOperationException("Unhandled static rewrite: " + opcode + " " + owner + " " + name + " " + descriptor);
+            }
+        } else {
+            throw new UnsupportedOperationException("Unhandled static rewrite: " + opcode + " " + owner + " " + name + " " + descriptor);
+        }
+        return new Rewrite(Opcodes.INVOKESTATIC, toOwner(this.newOwner()), name, this.modifyMethodDescriptor(desc).descriptorString(), false);
+    }
+
+    record Plain(Set<Class<?>> owners, NameAndDescPredicate nameAndDesc, ClassDesc newOwner) implements StaticRewrite {
+    }
+
+    record FuzzyParam(Set<Class<?>> owners, NameAndDescPredicate nameAndDesc, Supplier<ClassDesc> newOwnerSupplier, Predicate<ClassDesc> fuzzyParam, Method fuzzyHandler) implements StaticRewrite {
+
+        @Override
+        public ClassDesc newOwner() {
+            return this.newOwnerSupplier().get();
+        }
+
+        private static final ClassDesc OBJECT = ClassDesc.of(Object.class.getName());
+
+        @Override
+        public MethodTypeDesc modifyMethodDescriptor(MethodTypeDesc methodDescriptor) {
+            for (int i = 0; i < methodDescriptor.parameterCount(); i++) {
+                if (this.fuzzyParam().test(methodDescriptor.parameterType(i))) {
+                    methodDescriptor = methodDescriptor.changeParameterType(i, OBJECT);
+                }
+            }
+            return methodDescriptor;
+        }
+
+        private MethodTypeDesc replaceFuzzyParams(MethodTypeDesc descriptor, final IntSet positions) {
+            for (int i = 0; i < descriptor.parameterCount(); i++) {
+                if (this.fuzzyParam().test(descriptor.parameterType(i))) {
+                    descriptor = descriptor.changeParameterType(i, OBJECT); // change all fuzzy arguments to Object
+                    positions.add(i);
+                }
+            }
+            return descriptor;
+        }
+
+        private void generateParameters(final GeneratorAdapter methodGenerator, final MethodTypeDesc descriptor, final IntSet fuzzyPositions) {
+            for (int i = 0; i < descriptor.parameterCount(); i++) {
+                methodGenerator.loadArg(i);
+                if (fuzzyPositions.contains(i)) {
+                    methodGenerator.invokeStatic(Type.getType(this.fuzzyHandler().getDeclaringClass()), org.objectweb.asm.commons.Method.getMethod(this.fuzzyHandler()));
+                }
+            }
+        }
+
+        private void generateConstructor(final MethodGeneratorFactory factory, final Constructor<?> constructor, MethodTypeDesc descriptor) {
+            final Class<?> declaringClass = constructor.getDeclaringClass();
+            descriptor = descriptor.changeReturnType(constructor.getDeclaringClass().describeConstable().orElseThrow());
+            final IntSet fuzzyPositions = new IntArraySet();
+            descriptor = this.replaceFuzzyParams(descriptor, fuzzyPositions);
+            final String typeName = toOwner(descriptor.returnType());
+            final GeneratorAdapter methodGenerator = factory.create(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, "create" + typeName.substring(typeName.lastIndexOf('/') + 1), descriptor.descriptorString());
+            methodGenerator.newInstance(Type.getType(declaringClass));
+            methodGenerator.dup();
+            this.generateParameters(methodGenerator, descriptor, fuzzyPositions);
+            methodGenerator.invokeConstructor(Type.getType(declaringClass), org.objectweb.asm.commons.Method.getMethod(constructor));
+            methodGenerator.returnValue();
+            methodGenerator.endMethod();
+        }
+
+        private void generateRegularMethod(final MethodGeneratorFactory factory, final Method method, MethodTypeDesc descriptor) {
+            final Class<?> declaringClass = method.getDeclaringClass();
+            if (!Modifier.isStatic(method.getModifiers())) { // if a non-static method, first param will be the owner type
+                descriptor = descriptor.insertParameterTypes(0, declaringClass.describeConstable().orElseThrow());
+            }
+            final IntSet fuzzyPositions = new IntArraySet();
+            descriptor = this.replaceFuzzyParams(descriptor, fuzzyPositions);
+            final GeneratorAdapter methodGenerator = factory.create(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, method.getName(), descriptor.descriptorString());
+            this.generateParameters(methodGenerator, descriptor, fuzzyPositions);
+            final org.objectweb.asm.commons.Method originalMethod = org.objectweb.asm.commons.Method.getMethod(method);
+            final Type originalOwner = Type.getType(declaringClass);
+            if (declaringClass.isInterface() && !Modifier.isStatic(method.getModifiers())) {
+                methodGenerator.invokeInterface(originalOwner, originalMethod);
+            } else if (!declaringClass.isInterface() && !Modifier.isStatic(method.getModifiers())) {
+                methodGenerator.invokeVirtual(originalOwner, originalMethod);
+            } else if (Modifier.isStatic(method.getModifiers())) {
+                methodGenerator.invokeStatic(originalOwner, originalMethod);
+            } else {
+                throw new IllegalStateException("unknown method type " + methodGenerator);
+            }
+            methodGenerator.returnValue();
+            methodGenerator.endMethod();
+        }
+
+        @Override
+        public void generateMethods(final MethodGeneratorFactory methodGeneratorFactory) {
+            this.matchingMethods().filter(methodPair -> {
+                return methodPair.right().parameterList().stream().anyMatch(this.fuzzyParam());
+            }).forEach(pair -> {
+                if (pair.left() instanceof final Method method) {
+                    this.generateRegularMethod(methodGeneratorFactory, method, pair.right());
+                } else if (pair.left() instanceof final Constructor<?> constructor) {
+                    this.generateConstructor(methodGeneratorFactory, constructor, pair.right());
+                } else {
+                    throw new IllegalStateException("Unknown executable " + pair.left());
+                }
+            });
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..87f0989d02ec34522fc8459d286ad669e16593b9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java
@@ -0,0 +1,100 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.MethodRewriteRule;
+import java.lang.constant.MethodTypeDesc;
+import java.util.Set;
+import java.util.function.Predicate;
+
+public final class MethodMatcher {
+    private final Predicate<String> anyDescriptor;
+    private final Predicate<String> anyName;
+    private final MethodRewriteRule.NameAndDescPredicate nameAndDesc;
+
+    private MethodMatcher(final Predicate<String> anyDescriptor, final Predicate<String> anyName, final MethodRewriteRule.NameAndDescPredicate nameAndDesc) {
+        this.anyDescriptor = anyDescriptor;
+        this.anyName = anyName;
+        this.nameAndDesc = nameAndDesc;
+    }
+
+    public boolean matches(final String name, final String descriptor) {
+        return this.anyName.test(name) || this.anyDescriptor.test(descriptor) || this.nameAndDesc.test(name, descriptor);
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static final class Builder {
+        private Predicate<String> anyDescriptor = s -> false;
+        private Predicate<String> anyName = s -> false;
+        private MethodRewriteRule.NameAndDescPredicate nameAndDesc = (n, d) -> false;
+
+        private Builder() {
+        }
+
+        public Builder matchAnyName(final String desc) {
+            this.anyName = this.anyName.or(s -> s.equals(desc));
+            return this;
+        }
+
+        public Builder matchAnyDesc(final String...names) {
+            for (final String name : names) {
+                this.anyDescriptor = this.anyDescriptor.or(s -> s.equals(name));
+            }
+            return this;
+        }
+
+        public Builder match(final String name, final Predicate<? super MethodTypeDesc> descPredicate) {
+            return this.match(n -> n.equals(name), descPredicate);
+        }
+
+        public Builder match(final Set<String> names, final Predicate<? super MethodTypeDesc> descPredicate) {
+            return this.match(names::contains, descPredicate);
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final String descriptor) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && d.equals(descriptor));
+            return this;
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final Set<String> descriptors) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && descriptors.contains(d));
+            return this;
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final Predicate<? super MethodTypeDesc> descPredicate) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && descPredicate.test(MethodTypeDesc.ofDescriptor(d)));
+            return this;
+        }
+
+        public Builder match(final String name, final String desc) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> n.equals(name) && d.equals(desc));
+            return this;
+        }
+
+        public Builder match(final String name, final Set<String> descs) {
+            for (final String s : descs) {
+                this.match(name, s);
+            }
+            return this;
+        }
+
+        public Builder match(final Set<String> names, final String desc) {
+            for (final String name : names) {
+                this.match(name, desc);
+            }
+            return this;
+        }
+
+        public Builder match(final Set<String> names, final Set<String> descs) {
+            for (final String name : names) {
+                this.match(name, descs);
+            }
+            return this;
+        }
+
+        public MethodMatcher build() {
+            return new MethodMatcher(this.anyDescriptor, this.anyName, this.nameAndDesc);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..917f7e1e2d860a49b9ab255cf9ad532ed87af2f9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java
@@ -0,0 +1,46 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import java.lang.reflect.Method;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+public interface RuleFactory {
+
+    static RuleFactory create(final Set<Class<?>> owners) {
+        return new RuleFactoryImpl(owners);
+    }
+
+    private static MethodMatcher runBuilderConsumer(final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        final MethodMatcher.Builder builder = MethodMatcher.builder();
+        builderConsumer.accept(builder);
+        return builder.build();
+    }
+
+    default void changeParam(final Class<?> oldParam, final Class<?> newParam, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.changeParam(oldParam, newParam, runBuilderConsumer(builderConsumer));
+    }
+
+    void changeParam(Class<?> oldParam, Class<?> newParam, MethodMatcher matcher);
+
+    default void changeReturnType(final Class<?> oldReturnType, final Class<?> newReturnType, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.changeReturnType(oldReturnType, newReturnType, runBuilderConsumer(builderConsumer));
+    }
+
+    void changeReturnType(Class<?> oldReturnType, Class<?> newReturnType, MethodMatcher matcher);
+
+    default void plainStaticRewrite(final Class<?> newOwner, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.plainStaticRewrite(newOwner, runBuilderConsumer(builderConsumer));
+    }
+
+    void plainStaticRewrite(Class<?> newOwner, MethodMatcher matcher);
+
+    default void fuzzyStaticRewrite(final Supplier<Class<?>> newOwner, final Class<?> fuzzyParameter, final Method fuzzyHandler, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.fuzzyStaticRewrite(newOwner, fuzzyParameter, fuzzyHandler, runBuilderConsumer(builderConsumer));
+    }
+
+    void fuzzyStaticRewrite(Supplier<Class<?>> newOwner, Class<?> fuzzyParameter, Method fuzzyHandler, MethodMatcher matcher);
+
+    RewriteRule build();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce9c3cf89bd8e976d9004aa3e52a500c6eaaa303
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.ChangeParameter;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.ChangeReturnType;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.StaticRewrite;
+import java.lang.constant.ClassDesc;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Supplier;
+
+final class RuleFactoryImpl implements RuleFactory {
+
+    final Set<Class<?>> owners;
+    final List<RewriteRule> rules = new ArrayList<>();
+
+    RuleFactoryImpl(final Set<Class<?>> owners) {
+        this.owners = Set.copyOf(owners);
+    }
+
+    @Override
+    public void changeParam(final Class<?> oldParam, final Class<?> newParam, final MethodMatcher matcher) {
+        this.rules.add(new ChangeParameter(this.owners, matcher::matches, ClassDesc.of(oldParam.getName()), ClassDesc.of(newParam.getName())));
+    }
+
+    @Override
+    public void changeReturnType(final Class<?> oldReturnType, final Class<?> newReturnType, final MethodMatcher matcher) {
+        this.rules.add(new ChangeReturnType(this.owners, matcher::matches, ClassDesc.of(oldReturnType.getName()), ClassDesc.of(newReturnType.getName())));
+    }
+
+    @Override
+    public void plainStaticRewrite(final Class<?> newOwner, final MethodMatcher matcher) {
+        this.rules.add(new StaticRewrite.Plain(this.owners, matcher::matches, ClassDesc.of(newOwner.getName())));
+    }
+
+    @Override
+    public void fuzzyStaticRewrite(final Supplier<Class<?>> newOwner, final Class<?> fuzzyParameter, final Method fuzzyHandler, final MethodMatcher matcher) {
+        this.rules.add(new StaticRewrite.FuzzyParam(this.owners, matcher::matches, () -> newOwner.get().describeConstable().orElseThrow(), d -> d.equals(fuzzyParameter.describeConstable().orElseThrow()), fuzzyHandler));
+    }
+
+    @Override
+    public RewriteRule build() {
+        return RewriteRule.chain(this.rules);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7a1bab3e714b3add08c1473a5d03c1348adb220
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java
@@ -0,0 +1,82 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.versions;
+
+import com.google.common.base.Suppliers;
+import io.papermc.paper.event.world.StructuresLocateEvent;
+import io.papermc.paper.math.Position;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.VersionedClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import it.unimi.dsi.fastutil.Pair;
+import java.lang.constant.ClassDesc;
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Supplier;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.World;
+import org.bukkit.block.SculkCatalyst;
+import org.bukkit.block.Sign;
+import org.bukkit.boss.DragonBattle;
+import org.bukkit.entity.Player;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+
+public class API_1_20_2 extends VersionedClassloaderBytecodeModifier {
+
+    private static final ClassDesc POSITION = ClassDesc.of(Position.class.getName());
+
+    private static final List<Pair<Set<Class<?>>, Set<String>>> SIMPLE_POSITION_CHANGES = List.of(
+        Pair.of(Set.of(Bukkit.class, Server.class), Set.of("isOwnedByCurrentRegion")),
+        Pair.of(Set.of(World.class), Set.of("rayTraceEntities", "rayTraceBlocks", "rayTrace")),
+        Pair.of(Set.of(SculkCatalyst.class), Set.of("bloom")),
+        Pair.of(Set.of(Sign.class), Set.of("getInteractableSideFor")),
+        Pair.of(Set.of(DragonBattle.class), Set.of("spawnNewGateway")),
+        Pair.of(Set.of(Player.class), Set.of("lookAt")),
+        Pair.of(Set.of(StructuresLocateEvent.Result.class), Set.of("<init>"))
+    );
+
+    private static final Method POSITION_FUZZY_HANDLER;
+    static {
+        try {
+            POSITION_FUZZY_HANDLER = API_1_20_2.class.getDeclaredMethod("toPos", Object.class);
+        } catch (final NoSuchMethodException throwable) {
+            throw new RuntimeException(throwable);
+        }
+    }
+
+    private static final Supplier<Class<?>> POSITION_DELEGATES = Suppliers.memoize(() -> defineGeneratedDelegates(API_1_20_2.class, API_1_20_2.POSITION_RULE));
+    private static final RewriteRule POSITION_RULE = RewriteRule.chain(SIMPLE_POSITION_CHANGES.stream().map(pair -> removePositionFromLocation(pair.left(), pair.right())).toList());
+
+
+    private static RewriteRule removePositionFromLocation(final Set<Class<?>> owners, final Set<String> methodNames) {
+        return RewriteRule.forOwners(owners, factory -> {
+            factory.fuzzyStaticRewrite(POSITION_DELEGATES, Position.class, POSITION_FUZZY_HANDLER, m -> m.match(methodNames, d -> d.parameterList().contains(POSITION)));
+        });
+    }
+
+    public API_1_20_2(final int api) {
+        super(api);
+    }
+
+    @Override
+    public byte[] modify(final PluginMeta config, final byte[] bytecode) {
+        final ClassReader cr = new ClassReader(bytecode);
+        final ClassWriter cw = new ClassWriter(cr, 0);
+        this.cv = cw;
+
+        cr.accept(this, 0);
+        return cw.toByteArray();
+    }
+
+    @Override
+    public MethodVisitor visitMethod(final int access, final String name, final String descriptor, final String signature, final String[] exceptions) {
+        return POSITION_RULE.createVisitor(this.api, super.visitMethod(access, name, descriptor, signature, exceptions), this);
+    }
+
+    public static Position toPos(final Object object) {
+        return object instanceof final Location loc ? loc.asPosition() : (Position) object;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
index 2e02f73b857c530a0cce3a8d6aae46e3b0966486..f6566a2fca2f4aa0b281f525e0aa6f8b0ef966f2 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
@@ -1,6 +1,7 @@
 package io.papermc.paper.plugin.provider.configuration.serializer.constraints;
 
 import io.papermc.paper.plugin.util.NamespaceChecker;
+import java.util.List;
 import org.spongepowered.configurate.objectmapping.meta.Constraint;
 import org.spongepowered.configurate.serialize.SerializationException;
 
@@ -17,7 +18,18 @@ import java.util.regex.Pattern;
 public final class PluginConfigConstraints {
 
     public static final Set<String> RESERVED_KEYS = Set.of("bukkit", "minecraft", "mojang", "spigot", "paper");
-    public static final Set<String> VALID_PAPER_VERSIONS = Set.of("1.19", "1.20");
+    public static final List<String> VALID_PAPER_VERSIONS = List.of(
+        //<editor-fold desc="API Versions" defaultstate="collapsed">
+        "1.19",
+        "1.19.1",
+        "1.19.2",
+        "1.19.3",
+        "1.19.4",
+        "1.20",
+        "1.20.1",
+        "1.20.2"
+        //</editor-fold>
+    );
 
     @Documented
     @Retention(RetentionPolicy.RUNTIME)
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index c3060d1d4d0caf369c6ab516cb424f45eb851019..ecd79b639a76bb689bfa7119051c68d7491d9856 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -1119,7 +1119,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public RayTraceResult rayTraceEntities(Location start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
         // Paper start
-        return rayTraceEntities((io.papermc.paper.math.Position) start, direction, maxDistance, raySize, filter);
+        return rayTraceEntities(start.asPosition(), direction, maxDistance, raySize, filter);
     }
 
     public RayTraceResult rayTraceEntities(io.papermc.paper.math.Position start, Vector direction, double maxDistance, double raySize, Predicate<Entity> filter) {
@@ -1177,7 +1177,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
         // Paper start
-        return this.rayTraceBlocks(start, direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, null);
+        return this.rayTraceBlocks(start.asPosition(), direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, null);
     }
 
     @Override
@@ -1208,7 +1208,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
         // Paper start
-        return this.rayTrace(start, direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, raySize, filter, null);
+        return this.rayTrace(start.asPosition(), direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, raySize, filter, null);
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
index 6eae6efa35a1ccc224e2f311e25ecf13e8647ec8..049adcf0dd7df6616965b035b40b216bd0cf7944 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
@@ -87,7 +87,7 @@ public class CraftEnderDragon extends CraftMob implements EnderDragon, CraftEnem
             this.getHandle().setPodium(null);
         } else {
             org.apache.commons.lang.Validate.isTrue(location.getWorld() == null || location.getWorld().equals(getWorld()), "You cannot set a podium in a different world to where the dragon is");
-            this.getHandle().setPodium(io.papermc.paper.util.MCUtil.toBlockPos(location));
+            this.getHandle().setPodium(io.papermc.paper.util.MCUtil.toBlockPos(location.asPosition()));
         }
     }
     // Paper end
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 83aaf3e6e377d731ce02f779f80b7bf5db46f89f..edd874ce68cc6e7227d60153d0e553c8b37ebc75 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1242,7 +1242,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         org.bukkit.util.Vector direction = targetLocation.getDirection();
         direction.multiply(9999999); // We need to move the target block.. FAR out
         targetLocation.add(direction);
-        this.lookAt(targetLocation, io.papermc.paper.entity.LookAnchor.EYES);
+        this.lookAt(targetLocation.asPosition(), io.papermc.paper.entity.LookAnchor.EYES);
         // Paper end
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 548c77592a3520e8053483644eba805079a14f1a..912b95e77899242653f61a22d670864c48670bb6 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -408,6 +408,7 @@ public final class CraftMagicNumbers implements UnsafeValues {
     public byte[] processClass(PluginDescriptionFile pdf, String path, byte[] clazz) {
         try {
             clazz = Commodore.convert(clazz, !CraftMagicNumbers.isLegacy(pdf));
+            clazz = io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier.bytecodeModifier().modify(pdf, clazz); // Paper - run plugins through our modifications as well
         } catch (Exception ex) {
             Bukkit.getLogger().log(Level.SEVERE, "Fatal error trying to convert " + pdf.getFullName() + ":" + path, ex);
         }
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier b/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
index 20dbe2775951bfcdb85c5d679ac86c77a93e0847..4a554839971953e6f2b19e674d68afb727a39adf 100644
--- a/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
+++ b/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
@@ -1 +1 @@
-io.papermc.paper.plugin.entrypoint.classloader.PaperClassloaderBytecodeModifier
+io.papermc.paper.plugin.entrypoint.classloader.bytecode.PaperClassloaderBytecodeModifier
