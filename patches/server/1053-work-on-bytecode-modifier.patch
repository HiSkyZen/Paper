From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Sun, 12 Nov 2023 16:56:03 -0800
Subject: [PATCH] work on bytecode modifier


diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java
deleted file mode 100644
index f9a2c55a354c877749db3f92956de802ae575788..0000000000000000000000000000000000000000
--- a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/PaperClassloaderBytecodeModifier.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package io.papermc.paper.plugin.entrypoint.classloader;
-
-import io.papermc.paper.plugin.configuration.PluginMeta;
-
-// Stub, implement in future.
-public class PaperClassloaderBytecodeModifier implements ClassloaderBytecodeModifier {
-
-    @Override
-    public byte[] modify(PluginMeta configuration, byte[] bytecode) {
-        return bytecode;
-    }
-}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..d5e3e2ec145de0af3de12460aa5acef6ba4b5f60
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/ClassContext.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public interface ClassContext {
+
+    String className();
+
+    @Nullable String superClassName();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..cbd0e83fb555dda83deb4c6588fc6804316a0935
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/DescriptorUtils.java
@@ -0,0 +1,18 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import java.lang.constant.ClassDesc;
+
+public final class DescriptorUtils {
+
+    public static ClassDesc fromOwner(final String owner) {
+        return ClassDesc.ofDescriptor("L" + owner + ";");
+    }
+
+    public static String toOwner(final ClassDesc desc) {
+        final String descriptor = desc.descriptorString();
+        return descriptor.substring(1, descriptor.length() - 1);
+    }
+
+    private DescriptorUtils() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b98d47f108956a39b75bbccb43507167c59a855
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/PaperClassloaderBytecodeModifier.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import com.google.common.collect.Iterators;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.versions.API_1_20_2;
+import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import net.minecraft.Util;
+import org.objectweb.asm.Opcodes;
+
+public class PaperClassloaderBytecodeModifier implements ClassloaderBytecodeModifier {
+
+    static final Map<String, ModifierFactory> MODIFIERS = Util.make(new LinkedHashMap<>(), map -> {
+        map.put("1.20.2", API_1_20_2::new);
+    });
+
+    @Override
+    public byte[] modify(final PluginMeta configuration, byte[] bytecode) {
+        int start = -1;
+        if (configuration.getAPIVersion() != null) {
+            int i = 0;
+            for (final Map.Entry<String, ModifierFactory> entry : MODIFIERS.entrySet()) {
+                final int pluginIdx = PluginConfigConstraints.VALID_PAPER_VERSIONS.indexOf(configuration.getAPIVersion());
+                final int modifierIdx = PluginConfigConstraints.VALID_PAPER_VERSIONS.indexOf(entry.getKey());
+                if (pluginIdx <= modifierIdx) {
+                    start = i;
+                    break;
+                }
+                i++;
+            }
+        } else {
+            start = 0;
+        }
+        if (start == -1) {
+            return bytecode; // no modification needed. The plugin version is newer than all versioned modifiers
+        }
+
+        final Iterator<Map.Entry<String, ModifierFactory>> iter = MODIFIERS.entrySet().iterator();
+        Iterators.advance(iter, start);
+        while (iter.hasNext()) {
+            final VersionedClassloaderBytecodeModifier modifier = iter.next().getValue().create(Opcodes.ASM9);
+            bytecode = modifier.modify(configuration, bytecode);
+        }
+        return bytecode;
+    }
+
+    private interface ModifierFactory {
+
+        VersionedClassloaderBytecodeModifier create(int api);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..34b7b69527264c672338623f13bc2c6858d1debb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/VersionedClassloaderBytecodeModifier.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier;
+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.ClassVisitor;
+
+public abstract class VersionedClassloaderBytecodeModifier extends ClassVisitor implements ClassloaderBytecodeModifier, ClassContext {
+
+    private @MonotonicNonNull String className;
+    private @Nullable String superClassName;
+
+    protected VersionedClassloaderBytecodeModifier(final int api) {
+        super(api);
+    }
+
+    @Override
+    public void visit(final int version, final int access, final String name, final @Nullable String signature, final @Nullable String superName, final String @Nullable [] interfaces) {
+        super.visit(version, access, name, signature, superName, interfaces);
+        this.className = name;
+        this.superClassName = superName;
+    }
+
+    @Override
+    public String className() {
+        return this.className;
+    }
+
+    @Override
+    public @Nullable String superClassName() {
+        return this.superClassName;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..f63c305dff1e754cdaea4f0f8055ed850eab6d5a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java
new file mode 100644
index 0000000000000000000000000000000000000000..f1452d345179a070ed237c6e86c24a1faec53a54
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeParameter.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
+
+public record ChangeParameter(Predicate<String> owner, NameAndDescPredicate nameAndDesc, ClassDesc oldParam, ClassDesc newParam) implements MethodRewriteRule {
+
+    @Override
+    public Rewrite rewrite(final ClassContext context, final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+        return new Rewrite(opcode, owner, name, this.replaceParameter(descriptor), isInterface);
+    }
+
+    private String replaceParameter(final String initialDescriptor) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(initialDescriptor);
+        ClassDesc[] parameterArray = desc.parameterArray();
+        for (int i = 0; i < parameterArray.length; i++) {
+            final ClassDesc classDesc = parameterArray[i];
+            if (classDesc.equals(ChangeParameter.this.oldParam())) {
+                desc = desc.changeParameterType(i, ChangeParameter.this.newParam());
+            }
+        }
+        return desc.descriptorString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java
new file mode 100644
index 0000000000000000000000000000000000000000..e3f904bbc1ebf36c6f74d767900d220079bafef3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/ChangeReturnType.java
@@ -0,0 +1,27 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.util.function.Predicate;
+
+/**
+ * Using this type requires that the actual type of the returned value not be changed so a cast
+ * will still succeed. This is significantly simpler than trying to handle actually changing
+ * the type.
+ */
+public record ChangeReturnType(Predicate<String> owner, NameAndDescPredicate nameAndDesc, ClassDesc oldReturn, ClassDesc newReturn) implements MethodRewriteRule {
+
+    @Override
+    public Rewrite rewrite(final ClassContext context, final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+        return new Rewrite(opcode, owner, name, this.replaceReturnType(descriptor), isInterface);
+    }
+
+    private String replaceReturnType(final String initialDescriptor) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(initialDescriptor);
+        if (desc.returnType().equals(this.oldReturn())) {
+            desc = desc.changeReturnType(this.newReturn());
+        }
+        return desc.descriptorString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..65709f020035a0e89f2870005f02a3cd9fdbad2c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/MethodRewriteRule.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.MethodVisitor;
+
+public interface MethodRewriteRule extends RewriteRule {
+
+    String LAMBDA_METAFACTORY_OWNER = "java/lang/invoke/LambdaMetafactory";
+
+    Predicate<String> owner();
+
+    NameAndDescPredicate nameAndDesc();
+
+    @Override
+    default MethodVisitor createVisitor(final int api, final MethodVisitor parent, final ClassContext context) {
+        return new MethodVisitor(api, parent) {
+            @Override
+            public void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+                if (MethodRewriteRule.this.owner().test(owner) && MethodRewriteRule.this.nameAndDesc().test(name, descriptor)) {
+                    final @Nullable Rewrite rewrite = MethodRewriteRule.this.rewrite(context, opcode, owner, name, descriptor, isInterface);
+                    if (rewrite != null) {
+                        super.visitMethodInsn(rewrite.opcode, rewrite.owner, rewrite.name, rewrite.descriptor, rewrite.isInterface);
+                        return;
+                    }
+                }
+                super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+            }
+
+            @Override
+            public void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle, final Object... bootstrapMethodArguments) {
+                if (LAMBDA_METAFACTORY_OWNER.equals(bootstrapMethodHandle.getOwner()) && bootstrapMethodArguments.length > 1 && bootstrapMethodArguments[1] instanceof Handle handle) {
+                    if (MethodRewriteRule.this.owner().test(handle.getOwner()) && MethodRewriteRule.this.nameAndDesc().test(handle.getName(), handle.getDesc())) {
+                        final @Nullable Rewrite rewrite = MethodRewriteRule.this.rewrite(context, handle.getTag(), handle.getOwner(), handle.getName(), handle.getDesc(), handle.isInterface());
+                        if (rewrite != null) {
+                            bootstrapMethodArguments[1] = new Handle(rewrite.opcode, rewrite.owner, rewrite.name, rewrite.descriptor, rewrite.isInterface);
+                        }
+                    }
+                }
+                super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);
+            }
+        };
+    }
+
+    @Nullable Rewrite rewrite(ClassContext context, int opcode, String owner, String name, String descriptor, boolean isInterface);
+
+    record Rewrite(int opcode, String owner, String name, String descriptor, boolean isInterface) {}
+
+    @FunctionalInterface
+    interface NameAndDescPredicate {
+
+        boolean test(String name, String desc);
+
+        default NameAndDescPredicate and(final NameAndDescPredicate other) {
+            return (name, desc) -> this.test(name, desc) && other.test(name, desc);
+        }
+
+        default NameAndDescPredicate or(final NameAndDescPredicate other) {
+            return (name, desc) -> this.test(name, desc) || other.test(name, desc);
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b4697de1d942319d511c539a388923863d8e608
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/RewriteRule.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder.RuleFactory;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Consumer;
+import org.objectweb.asm.MethodVisitor;
+
+public interface RewriteRule {
+
+    static RewriteRule forOwner(final String owner, final Consumer<? super RuleFactory> factoryConsumer) {
+        return forOwners(Collections.singleton(owner), factoryConsumer);
+    }
+
+    static RewriteRule forOwners(final Set<String> owners, final Consumer<? super RuleFactory> factoryConsumer) {
+        final RuleFactory factory = RuleFactory.create(owners);
+        factoryConsumer.accept(factory);
+        return factory.build();
+    }
+
+    static RewriteRule chain(final RewriteRule... rules) {
+        return chain(Arrays.asList(rules));
+    }
+
+    static RewriteRule chain(final List<? extends RewriteRule> rules) {
+        return new Chain(List.copyOf(rules));
+    }
+
+    MethodVisitor createVisitor(int api, MethodVisitor parent, final ClassContext context);
+
+    final class Chain implements RewriteRule {
+
+        private final List<RewriteRule> rules;
+
+        private Chain(final List<RewriteRule> rules) {
+            this.rules = rules;
+        }
+
+        @Override
+        public MethodVisitor createVisitor(final int api, final MethodVisitor parent, final ClassContext context) {
+            MethodVisitor visitor = parent;
+            for (final RewriteRule rule : this.rules) {
+                visitor = rule.createVisitor(api, visitor, context);
+            }
+            return visitor;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java
new file mode 100644
index 0000000000000000000000000000000000000000..19f802ea05bcaa7e24455776b41b2b97441006f6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/StaticRewrite.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.ClassContext;
+import java.lang.constant.ClassDesc;
+import java.lang.constant.MethodTypeDesc;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.objectweb.asm.Opcodes;
+
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.DescriptorUtils.fromOwner;
+import static io.papermc.paper.plugin.entrypoint.classloader.bytecode.DescriptorUtils.toOwner;
+
+public interface StaticRewrite extends MethodRewriteRule {
+
+    ClassDesc newOwner();
+
+    default MethodTypeDesc modifyMethodDescriptor(final MethodTypeDesc methodDescriptor) {
+        return methodDescriptor;
+    }
+
+    @Override
+    default @Nullable Rewrite rewrite(final ClassContext context, final int opcode, final String owner, final String name, final String descriptor, final boolean isInterface) {
+        MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(descriptor);
+        if (opcode == Opcodes.INVOKEVIRTUAL || opcode == Opcodes.INVOKEINTERFACE) { // insert owner object as first param
+            desc = desc.insertParameterTypes(0, fromOwner(owner));
+        }
+        return new Rewrite(Opcodes.INVOKESTATIC, toOwner(this.newOwner()), name, this.modifyMethodDescriptor(desc).descriptorString(), false);
+    }
+
+    record Plain(Predicate<String> owner, NameAndDescPredicate nameAndDesc, ClassDesc newOwner) implements StaticRewrite {
+    }
+
+    record FuzzyParam(Predicate<String> owner, NameAndDescPredicate nameAndDesc, ClassDesc newOwner, Predicate<ClassDesc> fuzzyParam) implements StaticRewrite {
+
+        private static final ClassDesc OBJECT = ClassDesc.of(Object.class.getName());
+
+        @Override
+        public MethodTypeDesc modifyMethodDescriptor(MethodTypeDesc methodDescriptor) {
+            for (int i = 0; i < methodDescriptor.parameterCount(); i++) {
+                if (this.fuzzyParam().test(methodDescriptor.parameterType(i))) {
+                    methodDescriptor = methodDescriptor.changeParameterType(i, OBJECT);
+                }
+            }
+            return methodDescriptor;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..87f0989d02ec34522fc8459d286ad669e16593b9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/MethodMatcher.java
@@ -0,0 +1,100 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.MethodRewriteRule;
+import java.lang.constant.MethodTypeDesc;
+import java.util.Set;
+import java.util.function.Predicate;
+
+public final class MethodMatcher {
+    private final Predicate<String> anyDescriptor;
+    private final Predicate<String> anyName;
+    private final MethodRewriteRule.NameAndDescPredicate nameAndDesc;
+
+    private MethodMatcher(final Predicate<String> anyDescriptor, final Predicate<String> anyName, final MethodRewriteRule.NameAndDescPredicate nameAndDesc) {
+        this.anyDescriptor = anyDescriptor;
+        this.anyName = anyName;
+        this.nameAndDesc = nameAndDesc;
+    }
+
+    public boolean matches(final String name, final String descriptor) {
+        return this.anyName.test(name) || this.anyDescriptor.test(descriptor) || this.nameAndDesc.test(name, descriptor);
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static final class Builder {
+        private Predicate<String> anyDescriptor = s -> false;
+        private Predicate<String> anyName = s -> false;
+        private MethodRewriteRule.NameAndDescPredicate nameAndDesc = (n, d) -> false;
+
+        private Builder() {
+        }
+
+        public Builder matchAnyName(final String desc) {
+            this.anyName = this.anyName.or(s -> s.equals(desc));
+            return this;
+        }
+
+        public Builder matchAnyDesc(final String...names) {
+            for (final String name : names) {
+                this.anyDescriptor = this.anyDescriptor.or(s -> s.equals(name));
+            }
+            return this;
+        }
+
+        public Builder match(final String name, final Predicate<? super MethodTypeDesc> descPredicate) {
+            return this.match(n -> n.equals(name), descPredicate);
+        }
+
+        public Builder match(final Set<String> names, final Predicate<? super MethodTypeDesc> descPredicate) {
+            return this.match(names::contains, descPredicate);
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final String descriptor) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && d.equals(descriptor));
+            return this;
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final Set<String> descriptors) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && descriptors.contains(d));
+            return this;
+        }
+
+        public Builder match(final Predicate<? super String> namePredicate, final Predicate<? super MethodTypeDesc> descPredicate) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> namePredicate.test(n) && descPredicate.test(MethodTypeDesc.ofDescriptor(d)));
+            return this;
+        }
+
+        public Builder match(final String name, final String desc) {
+            this.nameAndDesc = this.nameAndDesc.or((n, d) -> n.equals(name) && d.equals(desc));
+            return this;
+        }
+
+        public Builder match(final String name, final Set<String> descs) {
+            for (final String s : descs) {
+                this.match(name, s);
+            }
+            return this;
+        }
+
+        public Builder match(final Set<String> names, final String desc) {
+            for (final String name : names) {
+                this.match(name, desc);
+            }
+            return this;
+        }
+
+        public Builder match(final Set<String> names, final Set<String> descs) {
+            for (final String name : names) {
+                this.match(name, descs);
+            }
+            return this;
+        }
+
+        public MethodMatcher build() {
+            return new MethodMatcher(this.anyDescriptor, this.anyName, this.nameAndDesc);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..a84e1f173767b2b28aa883fa579682680cc742a5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactory.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import java.util.Set;
+import java.util.function.Consumer;
+
+public interface RuleFactory {
+
+    static RuleFactory create(final Set<String> owners) {
+        return new RuleFactoryImpl(owners);
+    }
+
+    private static MethodMatcher runBuilderConsumer(final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        final MethodMatcher.Builder builder = MethodMatcher.builder();
+        builderConsumer.accept(builder);
+        return builder.build();
+    }
+
+    default void changeParam(final Class<?> oldParam, final Class<?> newParam, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.changeParam(oldParam, newParam, runBuilderConsumer(builderConsumer));
+    }
+
+    void changeParam(Class<?> oldParam, Class<?> newParam, MethodMatcher matcher);
+
+    default void changeReturnType(final Class<?> oldReturnType, final Class<?> newReturnType, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.changeReturnType(oldReturnType, newReturnType, runBuilderConsumer(builderConsumer));
+    }
+
+    void changeReturnType(Class<?> oldReturnType, Class<?> newReturnType, MethodMatcher matcher);
+
+    default void plainStaticRewrite(final Class<?> newOwner, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.plainStaticRewrite(newOwner, runBuilderConsumer(builderConsumer));
+    }
+
+    void plainStaticRewrite(Class<?> newOwner, MethodMatcher matcher);
+
+    default void fuzzyStaticRewrite(final Class<?> newOwner, final Class<?> fuzzyParameter, final Consumer<? super MethodMatcher.Builder> builderConsumer) {
+        this.fuzzyStaticRewrite(newOwner, fuzzyParameter, runBuilderConsumer(builderConsumer));
+    }
+
+    void fuzzyStaticRewrite(Class<?> newOwner, Class<?> fuzzyParameter, MethodMatcher matcher);
+
+    RewriteRule build();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..61969d8a39d7006f456a7b0305e2c9d92a64ba73
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/rules/builder/RuleFactoryImpl.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.builder;
+
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.ChangeParameter;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.ChangeReturnType;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.StaticRewrite;
+import java.lang.constant.ClassDesc;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+final class RuleFactoryImpl implements RuleFactory {
+
+    final Set<String> owners;
+    final List<RewriteRule> rules = new ArrayList<>();
+
+    RuleFactoryImpl(final Set<String> owners) {
+        this.owners = owners;
+    }
+
+    @Override
+    public void changeParam(final Class<?> oldParam, final Class<?> newParam, final MethodMatcher matcher) {
+        this.rules.add(new ChangeParameter(this.owners::contains, matcher::matches, ClassDesc.of(oldParam.getName()), ClassDesc.of(newParam.getName())));
+    }
+
+    @Override
+    public void changeReturnType(final Class<?> oldReturnType, final Class<?> newReturnType, final MethodMatcher matcher) {
+        this.rules.add(new ChangeReturnType(this.owners::contains, matcher::matches, ClassDesc.of(oldReturnType.getName()), ClassDesc.of(newReturnType.getName())));
+    }
+
+    @Override
+    public void plainStaticRewrite(final Class<?> newOwner, final MethodMatcher matcher) {
+        this.rules.add(new StaticRewrite.Plain(this.owners::contains, matcher::matches, ClassDesc.of(newOwner.getName())));
+    }
+
+    @Override
+    public void fuzzyStaticRewrite(final Class<?> newOwner, final Class<?> fuzzyParameter, final MethodMatcher matcher) {
+        this.rules.add(new StaticRewrite.FuzzyParam(this.owners::contains, matcher::matches, newOwner.describeConstable().orElseThrow(), d -> d.equals(fuzzyParameter.describeConstable().orElseThrow())));
+    }
+
+    @Override
+    public RewriteRule build() {
+        return RewriteRule.chain(this.rules);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java
new file mode 100644
index 0000000000000000000000000000000000000000..869dadd98f421b09476be0618b9f7b8fcb36c8e3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/entrypoint/classloader/bytecode/versions/API_1_20_2.java
@@ -0,0 +1,56 @@
+package io.papermc.paper.plugin.entrypoint.classloader.bytecode.versions;
+
+import io.papermc.paper.math.Position;
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.VersionedClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.entrypoint.classloader.bytecode.rules.RewriteRule;
+import java.lang.constant.ClassDesc;
+import java.util.Set;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.World;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.MethodVisitor;
+
+public class API_1_20_2 extends VersionedClassloaderBytecodeModifier {
+
+    private static final ClassDesc POSITION = ClassDesc.of(Position.class.getName());
+
+    public API_1_20_2(final int api) {
+        super(api);
+    }
+
+    @Override
+    public byte[] modify(final PluginMeta config, final byte[] bytecode) {
+        final ClassReader cr = new ClassReader(bytecode);
+        final ClassWriter cw = new ClassWriter(cr, 0);
+        this.cv = cw;
+
+        cr.accept(this, 0);
+        return cw.toByteArray();
+    }
+
+    @Override
+    public MethodVisitor visitMethod(final int access, final String name, final String descriptor, final String signature, final String[] exceptions) {
+        final RewriteRule rule = RewriteRule.forOwners(Set.of("org/bukkit/Bukkit", "org/bukkit/Server"), factory -> {
+            factory.fuzzyStaticRewrite(API_1_20_2.class, Position.class, m -> m.match("isOwnedByCurrentRegion", d -> d.parameterList().contains(POSITION)));
+        });
+        return rule.createVisitor(this.api, super.visitMethod(access, name, descriptor, signature, exceptions), this);
+    }
+
+    public static boolean isOwnedByCurrentRegion(final World world, final Object position) {
+        return isOwnedByCurrentRegion(Bukkit.getServer(), world, position);
+    }
+
+    public static boolean isOwnedByCurrentRegion(final Server server, final World world, final Object position) {
+        final Position pos;
+        if (position instanceof final Location location) {
+            pos = location.asPosition();
+        } else {
+            pos = (Position) position;
+        }
+        return server.isOwnedByCurrentRegion(world, pos);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
index 2e02f73b857c530a0cce3a8d6aae46e3b0966486..f6566a2fca2f4aa0b281f525e0aa6f8b0ef966f2 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
@@ -1,6 +1,7 @@
 package io.papermc.paper.plugin.provider.configuration.serializer.constraints;
 
 import io.papermc.paper.plugin.util.NamespaceChecker;
+import java.util.List;
 import org.spongepowered.configurate.objectmapping.meta.Constraint;
 import org.spongepowered.configurate.serialize.SerializationException;
 
@@ -17,7 +18,18 @@ import java.util.regex.Pattern;
 public final class PluginConfigConstraints {
 
     public static final Set<String> RESERVED_KEYS = Set.of("bukkit", "minecraft", "mojang", "spigot", "paper");
-    public static final Set<String> VALID_PAPER_VERSIONS = Set.of("1.19", "1.20");
+    public static final List<String> VALID_PAPER_VERSIONS = List.of(
+        //<editor-fold desc="API Versions" defaultstate="collapsed">
+        "1.19",
+        "1.19.1",
+        "1.19.2",
+        "1.19.3",
+        "1.19.4",
+        "1.20",
+        "1.20.1",
+        "1.20.2"
+        //</editor-fold>
+    );
 
     @Documented
     @Retention(RetentionPolicy.RUNTIME)
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index c3060d1d4d0caf369c6ab516cb424f45eb851019..70fb633c681d154f5cd51cf9d80a6247eef94424 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -1177,7 +1177,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public RayTraceResult rayTraceBlocks(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks) {
         // Paper start
-        return this.rayTraceBlocks(start, direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, null);
+        return this.rayTraceBlocks(start.asPosition(), direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, null);
     }
 
     @Override
@@ -1208,7 +1208,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode, boolean ignorePassableBlocks, double raySize, Predicate<Entity> filter) {
         // Paper start
-        return this.rayTrace(start, direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, raySize, filter, null);
+        return this.rayTrace(start.asPosition(), direction, maxDistance, fluidCollisionMode, ignorePassableBlocks, raySize, filter, null);
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
index 6eae6efa35a1ccc224e2f311e25ecf13e8647ec8..049adcf0dd7df6616965b035b40b216bd0cf7944 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEnderDragon.java
@@ -87,7 +87,7 @@ public class CraftEnderDragon extends CraftMob implements EnderDragon, CraftEnem
             this.getHandle().setPodium(null);
         } else {
             org.apache.commons.lang.Validate.isTrue(location.getWorld() == null || location.getWorld().equals(getWorld()), "You cannot set a podium in a different world to where the dragon is");
-            this.getHandle().setPodium(io.papermc.paper.util.MCUtil.toBlockPos(location));
+            this.getHandle().setPodium(io.papermc.paper.util.MCUtil.toBlockPos(location.asPosition()));
         }
     }
     // Paper end
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 83aaf3e6e377d731ce02f779f80b7bf5db46f89f..edd874ce68cc6e7227d60153d0e553c8b37ebc75 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1242,7 +1242,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         org.bukkit.util.Vector direction = targetLocation.getDirection();
         direction.multiply(9999999); // We need to move the target block.. FAR out
         targetLocation.add(direction);
-        this.lookAt(targetLocation, io.papermc.paper.entity.LookAnchor.EYES);
+        this.lookAt(targetLocation.asPosition(), io.papermc.paper.entity.LookAnchor.EYES);
         // Paper end
     }
 
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier b/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
index 20dbe2775951bfcdb85c5d679ac86c77a93e0847..4a554839971953e6f2b19e674d68afb727a39adf 100644
--- a/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
+++ b/src/main/resources/META-INF/services/io.papermc.paper.plugin.entrypoint.classloader.ClassloaderBytecodeModifier
@@ -1 +1 @@
-io.papermc.paper.plugin.entrypoint.classloader.PaperClassloaderBytecodeModifier
+io.papermc.paper.plugin.entrypoint.classloader.bytecode.PaperClassloaderBytecodeModifier
